<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guided Project: Graphs I</title>
    <meta name="identifier" content="g01f9eb02c97e2e7a4de50690705d50ee"/>
    <meta name="editing_roles" content="teachers"/>
    <meta name="workflow_state" content="unpublished"/>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #1a1d23; /* Dark background color */
            color: #ffffff;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #222831; /* Darker container background */
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        h1, h2, h3, h4 {
            color: #ffffff;
            margin: 0;
        }
        h1 {
            color: #ffffff;
            margin-bottom: 30px;
            border-bottom: 2px solid #ff5722; /* Orange accent color */
            padding-bottom: 10px;
            text-align: center;
            font-size: 2.5rem;
        }
        h2 {
            color: #ffffff;
            margin-top: 10px;
            margin-bottom: 20px;
            font-size: 1.75rem;
        }
        h3 {
            color: #ff5722; /* Orange accent color */
            margin-top: 0;
            font-size: 1.25rem;
            margin-bottom: 15px;
        }
        h4 {
            color: #ffffff;
            margin-top: 10px;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        p {
            color: #b3b3b3;
            margin-bottom: 16px;
        }
        
        /* Navigation */
        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        .nav-link {
            color: #ff5722;
            text-decoration: none;
            display: flex;
            align-items: center;
            transition: color 0.2s;
        }
        .nav-link:hover {
            color: #ff7043;
            text-decoration: underline;
        }
        .nav-link svg {
            width: 20px;
            height: 20px;
            margin-right: 8px;
        }
        
        /* Header */
        .header-section {
            text-align: center;
            margin-bottom: 30px;
        }
        .header-description {
            max-width: 800px;
            margin: 0 auto;
            margin-top: 15px;
            font-size: 1.2rem;
        }
        
        /* Section styling */
        .section {
            margin-bottom: 40px;
            background-color: #2a303c;
            border-radius: 4px;
            padding: 20px;
            border: 1px solid #333a47;
        }
        
        /* Content wrapper */
        .content-wrapper {
            margin-top: 30px;
        }
        
        /* Code blocks */
        .code-block {
            background-color: #1a1d23;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            overflow-x: auto;
        }
        code {
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre;
            font-size: 1rem;
        }
        
        /* Example usage */
        .info-box {
            background-color: #333a47;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        /* Lists */
        ul, ol {
            color: #b3b3b3;
            padding-left: 20px;
            margin-left: 0;
            margin-bottom: 20px;
        }
        li {
            margin-bottom: 10px;
        }
        
        /* Video container */
        .wistia-responsive-padding {
            padding: 56.25% 0 0 0;
            position: relative;
        }
        .wistia-responsive-wrapper {
            height: 100%;
            left: 0;
            position: absolute;
            top: 0;
            width: 100%;
        }
        .video-container {
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 30px;
        }
        
        /* Links */
        .link {
            color: #ff5722;
            text-decoration: none;
            transition: color 0.2s;
        }
        .link:hover {
            color: #ff7043;
            text-decoration: underline;
        }
        
        /* Spacing utilities */
        .space-y {
            margin-bottom: 30px;
        }
        
        /* Grid layout */
        .grid {
            display: grid;
            gap: 20px;
        }
        .grid-cols-1 {
            grid-template-columns: 1fr;
        }
        @media (min-width: 768px) {
            .grid-cols-2 {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Tab navigation */
        .tab-navigation {
            display: flex;
            border-bottom: 1px solid #333a47;
            margin-bottom: 30px;
        }
        .tab-button {
            background: none;
            border: none;
            color: #b3b3b3;
            padding: 12px 16px;
            margin-right: 20px;
            font-size: 1rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .tab-button:hover {
            color: #ffffff;
        }
        .tab-button.active {
            color: #ff5722;
            border-bottom: 2px solid #ff5722;
        }
        
        /* Hidden content */
        .hidden {
            display: none;
        }
        
        /* Example scenarios */
        .example-box {
            background-color: #333a47;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .example-code {
            background-color: #1a1d23;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            color: #e0e0e0;
            margin-top: 8px;
        }
        
        /* Strong emphasis */
        strong {
            color: #fff;
            font-weight: bold;
        }
    </style>
    <script>
        function switchTab(tabId, element) {
            document.querySelectorAll('[data-tab-content]').forEach(content => {
                content.classList.add('hidden');
            });
            document.querySelectorAll('[data-tab]').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-tab-content="${tabId}"]`).classList.remove('hidden');
            element.classList.add('active');
        }
    </script>
</head>
<body>
    <div class="container">
        <!-- Navigation -->
        <div class="nav-container">
            <a href="../welcome.html" class="nav-link">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                </svg>
                <span>Back to Welcome Page</span>
            </a>
        </div>

        <!-- Header Section -->
        <div class="header-section">
            <h1>Guided Project: Detecting Cycles in Graphs</h1>
            <p class="header-description">
                Learn how to implement cycle detection in graphs using depth-first search.
                Master this essential algorithm used in various real-world applications.
            </p>
        </div>

        <!-- Main Navigation Tabs -->
        <div class="tab-navigation">
            <button 
                data-tab="overview"
                onclick="switchTab('overview', this)"
                class="tab-button active">
                Overview
            </button>
            <button 
                data-tab="guided-implementation"
                onclick="switchTab('guided-implementation', this)"
                class="tab-button">
                Guided Implementation
            </button>
            <button 
                data-tab="practice"
                onclick="switchTab('practice', this)"
                class="tab-button">
                Practice Challenge
            </button>
        </div>

        <!-- Tab Contents -->
        <div class="content-wrapper">
            <!-- Overview Tab -->
            <div data-tab-content="overview" class="space-y">
                <div class="section">
                    <h2>Project Overview</h2>
                    <div class="grid grid-cols-2">
                        <div class="space-y">
                            <h3>Learning Goals</h3>
                            <ul>
                                <li>Understand cycle detection algorithms</li>
                                <li>Implement DFS-based cycle detection</li>
                                <li>Handle directed and undirected graphs</li>
                                <li>Analyze algorithm complexity</li>
                            </ul>
                        </div>
                        <div class="space-y">
                            <h3>Prerequisites</h3>
                            <ul>
                                <li>Graph fundamentals</li>
                                <li>Depth-first search</li>
                                <li>JavaScript classes</li>
                                <li>Recursive functions</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2>Real-World Applications</h2>
                    <div class="grid grid-cols-2">
                        <div class="space-y">
                            <h3>Use Cases</h3>
                            <ul>
                                <li>Deadlock detection in operating systems</li>
                                <li>Dependency resolution in package managers</li>
                                <li>Circuit design verification</li>
                                <li>Network topology analysis</li>
                            </ul>
                        </div>
                        <div class="space-y">
                            <h3>Example Scenarios</h3>
                            <div class="example-box">
                                <p>Deadlock Example:</p>
                                <div class="example-code">Process A → Resource 1 → Process B → Resource 2 → Process A
(Cycle indicates potential deadlock)</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Guided Implementation Tab -->
            <div data-tab-content="guided-implementation" class="hidden space-y">
                <div class="section">
                    <h2>Detecting Cycles in Graphs</h2>
                    
                    <!-- Video Section -->
                    <div class="space-y">
                        <div class="video-container">
                            <div class="wistia-responsive-padding">
                                <div class="wistia-responsive-wrapper">
                                    <iframe src="https://fast.wistia.net/embed/iframe/cz1gs6r8ew?videoFoam=true" title="s20M1 Web-JavaScript Guided Project Detecting Cycles Video" allow="autoplay; fullscreen" allowtransparency="true" frameborder="0" scrolling="no" width="100%" height="100%"></iframe>
                                </div>
                            </div>
                        </div>

                        <!-- Implementation Overview -->
                        <div class="info-box">
                            <h3>Understanding Cycle Detection</h3>
                            <p>
                                A cycle in a graph is a path where the first and last vertices are the same. Cycle detection is a fundamental graph problem with applications in deadlock detection, dependency resolution, and circuit design verification.
                            </p>
                            <p>
                                For directed graphs, we use a recursive DFS approach with a "recursion stack" to keep track of vertices being processed in the current path. If a vertex is visited again and it's in the recursion stack, we've found a cycle.
                            </p>
                            <p>
                                For undirected graphs, we use a simpler approach: if we encounter a vertex that has already been visited and it's not the parent of the current vertex, we've found a cycle.
                            </p>
                        </div>

                        <!-- Implementation Steps -->
                        <div class="space-y">
                            <h3>Implementation Steps</h3>
                            
                            <div class="grid grid-cols-2">
                                <div class="space-y">
                                    <h4>Step 1: Graph Setup</h4>
                                    <div class="code-block">
                                        <code>class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }

    addEdge(v1, v2) {
        this.adjacencyList[v1].push(v2);
        // For undirected graphs, add:
        // this.adjacencyList[v2].push(v1);
    }
}</code>
                                    </div>
                                </div>

                                <div class="space-y">
                                    <h4>Step 2: Cycle Detection Method</h4>
                                    <div class="code-block">
                                        <code>hasCycle() {
    const visited = {};
    const recStack = {};

    // Check all vertices (for disconnected graphs)
    for (let vertex in this.adjacencyList) {
        if (this.hasCycleUtil(vertex, visited, recStack)) {
            return true;
        }
    }
    return false;
}</code>
                                    </div>
                                </div>
                            </div>

                            <div class="space-y">
                                <h4>Step 3: Helper Method for Cycle Detection</h4>
                                <div class="code-block">
                                    <code>hasCycleUtil(vertex, visited, recStack) {
    // If not visited, mark as visited
    if (!visited[vertex]) {
        visited[vertex] = true;
        recStack[vertex] = true;  // Add to recursion stack

        // Check all neighbors
        for (let neighbor of this.adjacencyList[vertex]) {
            // If neighbor not visited and has cycle
            if (!visited[neighbor] && 
                this.hasCycleUtil(neighbor, visited, recStack)) {
                return true;
            } 
            // If neighbor is in recursion stack, cycle found
            else if (recStack[neighbor]) {
                return true;
            }
        }
    }
    
    // Remove from recursion stack when backtracking
    recStack[vertex] = false;
    return false;
}</code>
                                </div>
                            </div>
                            
                            <!-- Cycle Detection for Undirected Graphs -->
                            <div class="space-y">
                                <h4>Cycle Detection for Undirected Graphs</h4>
                                <div class="code-block">
                                    <code>hasCycleUndirected() {
    const visited = {};
    
    // Helper function
    const hasCycleUtil = (vertex, parent) => {
        // Mark current node as visited
        visited[vertex] = true;
        
        // Visit all adjacent vertices
        for (let neighbor of this.adjacencyList[vertex]) {
            // If neighbor is not visited, recursively check
            if (!visited[neighbor]) {
                if (hasCycleUtil(neighbor, vertex)) {
                    return true;
                }
            } 
            // If neighbor is visited and not the parent,
            // then there is a cycle
            else if (neighbor !== parent) {
                return true;
            }
        }
        return false;
    };
    
    // Check all vertices (for disconnected graphs)
    for (let vertex in this.adjacencyList) {
        if (!visited[vertex]) {
            if (hasCycleUtil(vertex, null)) {
                return true;
            }
        }
    }
    
    return false;
}</code>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Example Usage -->
                        <div class="space-y">
                            <h3>Example Usage</h3>
                            <div class="code-block">
                                <code>// Create a directed graph
const graph = new Graph();

// Add vertices
graph.addVertex("A");
graph.addVertex("B");
graph.addVertex("C");
graph.addVertex("D");

// Add edges (directed)
graph.addEdge("A", "B");
graph.addEdge("B", "C");
graph.addEdge("C", "A");  // Creates a cycle A -> B -> C -> A
graph.addEdge("D", "C");

// Check for cycles
console.log(graph.hasCycle());  // Output: true

// Visualize the graph structure
console.log(graph.adjacencyList);
/*
{
  A: ["B"],
  B: ["C"],
  C: ["A"],
  D: ["C"]
}
*/</code>
                            </div>
                        </div>
                        
                        <!-- Practice with LeetCode -->
                        <div class="space-y">
                            <h3>Practice with LeetCode</h3>
                            <p>Cycle detection is a common interview question and appears in many practical problems. Practice with these LeetCode problems:</p>
                            <ul>
                                <li>
                                    <a href="https://leetcode.com/problems/course-schedule/" class="link">Course Schedule</a>
                                    <span class="text-gray-600 ml-2">- Determine if you can finish all courses (cycle detection in directed graph)</span>
                                </li>
                                <li>
                                    <a href="https://leetcode.com/problems/redundant-connection/" class="link">Redundant Connection</a>
                                    <span class="text-gray-600 ml-2">- Find an edge that can be removed to make a tree (cycle detection in undirected graph)</span>
                                </li>
                                <li>
                                    <a href="https://leetcode.com/problems/find-eventual-safe-states/" class="link">Find Eventual Safe States</a>
                                    <span class="text-gray-600 ml-2">- Find all vertices that don't belong to a cycle</span>
                                </li>
                            </ul>
                            <p class="text-gray-700 mt-4">
                                Note: Previously, this course referenced the CodeSignal Arcade, which is no longer available. The LeetCode problems above follow the same principles and are an excellent alternative for practicing graph algorithms and preparing for technical interviews.
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Practice Challenge Tab -->
            <div data-tab-content="practice" class="hidden space-y">
                <div class="section">
                    <h2>Practice Challenge: Implement Cycle Detection</h2>
                    <p>Now that you've learned how to detect cycles in graphs, try implementing the algorithm yourself.</p>
                    
                    <div class="space-y">
                        <h3>Challenge Description</h3>
                        <p>Implement a cycle detection algorithm for both directed and undirected graphs.</p>
                        
                        <div class="info-box">
                            <h4>Requirements:</h4>
                            <ul>
                                <li>Add a method to detect cycles in a directed graph</li>
                                <li>Add a method to detect cycles in an undirected graph</li>
                                <li>Return true if a cycle is found, false otherwise</li>
                                <li>Use the Graph class provided in the guided implementation</li>
                            </ul>
                        </div>
                        
                        <div class="space-y">
                            <h3>Code Starting Point</h3>
                            <div class="code-block">
                                <code>class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }

    addEdge(v1, v2, directed = true) {
        this.adjacencyList[v1].push(v2);
        if (!directed) {
            this.adjacencyList[v2].push(v1);
        }
    }
    
    // Implement cycle detection for directed graphs
    hasCycleDirected() {
        // Your code here
    }
    
    // Implement cycle detection for undirected graphs
    hasCycleUndirected() {
        // Your code here
    }
}</code>
                            </div>
                        </div>
                        
                        <div class="space-y">
                            <h3>Testing Your Solution</h3>
                            <div class="code-block">
                                <code>// Create a directed graph with a cycle
const directedGraph = new Graph();
directedGraph.addVertex('A');
directedGraph.addVertex('B');
directedGraph.addVertex('C');
directedGraph.addVertex('D');
directedGraph.addEdge('A', 'B');
directedGraph.addEdge('B', 'C');
directedGraph.addEdge('C', 'D');
directedGraph.addEdge('D', 'B'); // Creates a cycle B → C → D → B
console.log(directedGraph.hasCycleDirected()); // Should return true

// Create an undirected graph with a cycle
const undirectedGraph = new Graph();
undirectedGraph.addVertex('A');
undirectedGraph.addVertex('B');
undirectedGraph.addVertex('C');
undirectedGraph.addEdge('A', 'B', false);
undirectedGraph.addEdge('B', 'C', false);
undirectedGraph.addEdge('C', 'A', false); // Creates a cycle A — B — C — A
console.log(undirectedGraph.hasCycleUndirected()); // Should return true</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>