<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Module 3: Introduction to Recursion</title>
<meta name="identifier" content="g808b234207be23fe4a1c059b7400a1f7"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
<script src="https://cdn.tailwindcss.com"></script>
<script>
    tailwind.config = {
        theme: {
            extend: {
                colors: {
                    primary: '#ff5722',
                    secondary: '#ff7043',
                    dark: '#1a1d23',
                    darker: '#222831', 
                    darkgray: '#2a303c',
                    darkborder: '#333a47',
                    lighttext: '#b3b3b3',
                }
            }
        }
    }
</script>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    line-height: 1.6;
    margin: 0;
    padding: 20px;
    background-color: #1a1d23; /* Dark background color */
    color: #ffffff;
  }
  
  h1, h2, h3, h4, h5 {
    color: #ffffff;
    margin-top: 20px;
    margin-bottom: 10px;
  }
  
  h3 {
    color: #ff5722; /* Orange accent color */
    border-bottom: 1px solid #333a47;
    padding-bottom: 8px;
  }
  
  p, ul, ol {
    color: #b3b3b3;
  }
  
  .code-block {
    background-color: #1e222a;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-family: monospace;
    white-space: pre;
    overflow-x: auto;
    color: #b3b3b3;
    border-left: 2px solid #ff5722;
  }
  
  .leetcode-link {
    color: #ff5722;
    text-decoration: none;
  }
  
  .leetcode-link:hover {
    text-decoration: underline;
    color: #ff7043;
  }
  
  .objectives-section {
    margin-bottom: 20px;
    padding: 15px;
    border-left: 3px solid #ff5722;
    background-color: #2a303c;
    border-radius: 4px;
  }
  
  .content-section {
    margin-bottom: 30px;
    background-color: #2a303c;
    border-radius: 4px;
    padding: 20px;
    border: 1px solid #333a47;
  }

  .content-section h4 {
    color: #ff5722;
    font-weight: bold;
    margin-bottom: 10px;
    border-bottom: 1px solid #333a47;
    padding-bottom: 8px;
  }

  /* Video container styles */
  .video-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    margin: 20px 0;
    border: 1px solid #333a47;
    border-radius: 4px;
  }
  
  .video-wrapper {
    height: 100%;
    left: 0;
    position: absolute;
    top: 0;
    width: 100%;
  }

  /* Table styles */
  .data-table {
    border-collapse: collapse;
    width: 100%;
    color: #b3b3b3;
  }

  .table-header {
    padding: 8px;
    background-color: #2a303c;
    color: #ffffff;
  }

  .table-cell {
    padding: 8px;
    border: 1px solid #333a47;
  }
  
  hr {
    border: 0;
    height: 1px;
    background-color: #333a47;
    margin: 30px 0;
  }
</style>
</head>
<body class="bg-dark min-h-screen">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <!-- Navigation -->
        <div class="flex justify-between items-center mb-8">
            <a href="welcome.html" class="text-primary hover:text-secondary flex items-center space-x-2">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                </svg>
                <span>Back to Welcome Page</span>
            </a>
        </div>

        <!-- Header Section -->
        <div class="text-center mb-12">
            <h1 class="text-4xl font-bold text-white mb-4">Module 3: Introduction to Recursion</h1>
            <p class="text-xl text-lighttext max-w-3xl mx-auto">
                Master the fundamentals of recursion.
                Learn how to implement and analyze recursive algorithms.
            </p>
        </div>

        <div class="objectives-section">
            <h2>Module Objectives</h2>
            <p>Upon completion of this module, you will be able to:</p>
            <ul>
                <li>Identify a recursive problem and determine when recursion is appropriate</li>
                <li>Define a recursive solution by breaking down a problem into smaller, similar problems</li>
                <li>Understand base cases and recursive cases in recursive functions</li>
                <li>Trace recursive function calls to understand execution flow</li>
                <li>Apply recursive solutions to linked list and tree problems</li>
                <li>Analyze the time and space complexity of recursive algorithms</li>
            </ul>
        </div>

        <h3><strong>Recursion Basics</strong></h3>
        <p>
        <div class="video-container">
            <div class="video-wrapper">
                <iframe class="wistia_embed" title="s17M3 JavaScript CC1 Recursion Basics Video" src="https://fast.wistia.net/embed/iframe/dy4ey5vozu" width="100%" height="100%" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe>
            </div>
        </div>
        </p>

        <div class="content-section">
            <h4>What is Recursion?</h4>
            <p class="mb-4">Recursion is a programming technique where a function calls itself to solve a problem. It's particularly useful for problems that can be broken down into smaller instances of the same problem.</p>
            
            <p class="mb-4"><strong>Key Components of Recursion:</strong></p>
            <ul class="mb-4">
                <li><strong>Base Case:</strong> A condition that stops the recursion</li>
                <li><strong>Recursive Case:</strong> The function calling itself with a smaller/simpler input</li>
                <li><strong>Progress Toward Base Case:</strong> Ensuring the recursion will eventually terminate</li>
            </ul>
            
            <h4>Simple Example: Factorial</h4>
            <div class="code-block">
// Recursive factorial function
function factorial(n) {
  // Base case
  if (n === 0 || n === 1) {
    return 1;
  }
  // Recursive case
  return n * factorial(n - 1);
}

// Example usage
console.log(factorial(5)); // 120 (5 * 4 * 3 * 2 * 1)
  </div>
  
  <h4>Recursive Function Tracing</h4>
  <p>Understanding how recursive calls stack up is crucial:</p>
  <div class="code-block">
// Tracing factorial(5):
factorial(5)
→ 5 * factorial(4)
  → 5 * (4 * factorial(3))
    → 5 * (4 * (3 * factorial(2)))
      → 5 * (4 * (3 * (2 * factorial(1))))
        → 5 * (4 * (3 * (2 * 1)))
      → 5 * (4 * (3 * 2))
    → 5 * (4 * 6)
  → 5 * 24
→ 120
  </div>
</div>

<div class="content-section">
  <h4>More Recursive Examples</h4>
  
  <h5>1. Fibonacci Sequence</h5>
  <div class="code-block">
// Recursive Fibonacci (inefficient but illustrative)
function fibonacci(n) {
  // Base cases
  if (n <= 0) return 0;
  if (n === 1) return 1;
  
  // Recursive case
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// Example usage
console.log(fibonacci(6)); // 8
  </div>
  
  <p>Note: The simple recursive implementation of Fibonacci has exponential time complexity O(2^n). For efficiency, you'd use dynamic programming or memoization:</p>
  
  <div class="code-block">
// Fibonacci with memoization
function fibonacciMemo(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 0) return 0;
  if (n === 1) return 1;
  
  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
  return memo[n];
}

// Example usage
console.log(fibonacciMemo(50)); // Much faster for large inputs
  </div>
  
  <h5>2. Linked List Recursion</h5>
  <div class="code-block">
// Node definition
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

// Find length of linked list recursively
function getLength(head) {
  // Base case: empty list
  if (head === null) {
    return 0;
  }
  
  // Recursive case: count this node plus the rest
  return 1 + getLength(head.next);
}

// Reverse a linked list recursively
function reverseList(head) {
  // Base cases: empty list or only one node
  if (head === null || head.next === null) {
    return head;
  }
  
  // Recursive case
  const newHead = reverseList(head.next);
  
  // Reverse the pointers
  head.next.next = head;
  head.next = null;
  
  return newHead;
}
  </div>
</div>

<div class="content-section">
  <h4>Recursion vs. Iteration</h4>
  <p>It's important to understand when to use recursion versus iterative approaches:</p>
  
  <table class="data-table">
    <tr>
      <th class="table-header">Aspect</th>
      <th class="table-header">Recursion</th>
      <th class="table-header">Iteration</th>
    </tr>
    <tr>
      <td class="table-cell">Memory Usage</td>
      <td class="table-cell">Uses call stack (higher memory overhead)</td>
      <td class="table-cell">Typically uses less memory</td>
    </tr>
    <tr>
      <td class="table-cell">Code Clarity</td>
      <td class="table-cell">Often more elegant and readable for certain problems</td>
      <td class="table-cell">May be more straightforward for simple problems</td>
    </tr>
    <tr>
      <td class="table-cell">Performance</td>
      <td class="table-cell">Can be slower due to function call overhead</td>
      <td class="table-cell">Usually faster</td>
    </tr>
    <tr>
      <td class="table-cell">Stack Overflow Risk</td>
      <td class="table-cell">Possible with deep recursion</td>
      <td class="table-cell">Not an issue</td>
    </tr>
    <tr>
      <td class="table-cell">Best For</td>
      <td class="table-cell">Tree traversals, divide-and-conquer algorithms</td>
      <td class="table-cell">Simple loops, performance-critical code</td>
    </tr>
  </table>
  
  <h5 class="mt-4">Iterative vs. Recursive Factorial Example</h5>
  <div class="code-block">
// Recursive
function factorialRecursive(n) {
  if (n === 0 || n === 1) return 1;
  return n * factorialRecursive(n - 1);
}

// Iterative
function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}
  </div>
</div>

<div class="content-section">
  <h4>Common Recursion Pitfalls</h4>
  <ul class="mb-4">
    <li><strong>Missing Base Case:</strong> Leads to infinite recursion and stack overflow</li>
    <li><strong>Inefficient Overlapping Subproblems:</strong> Can make recursion exponentially slow</li>
    <li><strong>Stack Overflow:</strong> With deeply nested recursion</li>
    <li><strong>Unnecessary Recursion:</strong> When an iterative solution is simpler</li>
  </ul>
  
  <h4>Techniques to Improve Recursive Solutions</h4>
  <ul>
    <li><strong>Memoization:</strong> Store results of subproblems to avoid redundant calculations</li>
    <li><strong>Tail Recursion:</strong> Special form where recursive call is the last operation</li>
    <li><strong>Trampolining:</strong> Technique to avoid stack overflow by simulating recursion</li>
  </ul>
</div>

<h3>Practice with LeetCode Problems</h3>

<p class="mb-4">Note: Previously, this course referenced the CodeSignal Arcade for practice, which is no longer available. The LeetCode problems below follow the same principles and are an excellent alternative for practicing recursion.</p>

<h4>Basic Recursion Problems:</h4>
<ul class="mb-4">
  <li><a href="https://leetcode.com/problems/fibonacci-number/" class="leetcode-link" target="_blank" rel="noopener">Fibonacci Number</a> - Classic recursion example</li>
  <li><a href="https://leetcode.com/problems/climbing-stairs/" class="leetcode-link" target="_blank" rel="noopener">Climbing Stairs</a> - Similar to Fibonacci but with a practical context</li>
  <li><a href="https://leetcode.com/problems/powx-n/" class="leetcode-link" target="_blank" rel="noopener">Pow(x, n)</a> - Implement power function using recursion</li>
</ul>

<h4>Recursive List Problems:</h4>
<ul class="mb-4">
  <li><a href="https://leetcode.com/problems/reverse-linked-list/" class="leetcode-link" target="_blank" rel="noopener">Reverse Linked List</a> - Practice recursive linked list manipulation</li>
  <li><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" class="leetcode-link" target="_blank" rel="noopener">Swap Nodes in Pairs</a> - Intermediate linked list recursion</li>
  <li><a href="https://leetcode.com/problems/merge-two-sorted-lists/" class="leetcode-link" target="_blank" rel="noopener">Merge Two Sorted Lists</a> - Can be solved elegantly with recursion</li>
</ul>

<h4>Tree Recursion:</h4>
<ul class="mb-4">
  <li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" class="leetcode-link" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a> - Simple tree recursion</li>
  <li><a href="https://leetcode.com/problems/same-tree/" class="leetcode-link" target="_blank" rel="noopener">Same Tree</a> - Compare two trees recursively</li>
  <li><a href="https://leetcode.com/problems/path-sum/" class="leetcode-link" target="_blank" rel="noopener">Path Sum</a> - Find paths in a tree recursively</li>
</ul>

<hr>
</body>
</html>