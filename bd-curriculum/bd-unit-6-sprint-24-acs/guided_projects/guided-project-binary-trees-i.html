<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guided Project: Binary Trees I</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #1a1d23;
            color: #ffffff;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #222831;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        h1, h2, h3, h4 {
            color: #ffffff;
            margin-top: 0;
        }
        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #ff5722;
            padding-bottom: 10px;
        }
        h2 {
            font-size: 1.8rem;
            color: #ffffff;
            margin-bottom: 20px;
        }
        h3 {
            font-size: 1.3rem;
            color: #ff5722;
            margin-bottom: 15px;
        }
        h4 {
            font-size: 1.1rem;
            margin-bottom: 10px;
        }
        p {
            color: #b3b3b3;
            margin-bottom: 16px;
        }
        .intro-text {
            text-align: center;
            max-width: 800px;
            margin: 0 auto 30px;
            color: #b3b3b3;
            font-size: 1.1rem;
        }
        .back-button {
            display: inline-block;
            margin-bottom: 20px;
            padding: 8px 16px;
            background-color: #2a303c;
            color: #ffffff;
            text-decoration: none;
            border-radius: 4px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            width: fit-content;
        }
        .back-button:hover {
            background-color: #333a47;
        }
        .back-button svg {
            margin-right: 5px;
            width: 16px;
            height: 16px;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #333a47;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        .tab {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: #b3b3b3;
            font-weight: 500;
            transition: all 0.2s;
            background: none;
            border-top: none;
            border-left: none;
            border-right: none;
            font-size: 0.9rem;
        }
        .tab:hover {
            color: #ffffff;
        }
        .tab.active {
            color: #ff5722;
            border-bottom: 2px solid #ff5722;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .card {
            background-color: #2a303c;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .feature-box {
            background-color: #333a47;
            border-radius: 8px;
            padding: 20px;
        }
        ul, ol {
            padding-left: 20px;
            color: #b3b3b3;
            margin-bottom: 20px;
        }
        li {
            margin-bottom: 8px;
        }
        li.feature-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 12px;
        }
        li.feature-item svg {
            color: #ff5722;
            margin-right: 10px;
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            margin-top: 3px;
        }
        .step-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 16px;
        }
        .step-number {
            background-color: #ff5722;
            color: #ffffff;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            flex-shrink: 0;
            margin-right: 16px;
        }
        .step-content {
            flex-grow: 1;
        }
        a {
            color: #ff5722;
            text-decoration: none;
        }
        a:hover {
            color: #ff7043;
            text-decoration: underline;
        }
        code, pre {
            font-family: 'Courier New', Courier, monospace;
            background-color: #333a47;
            color: #f5f5f5;
            border-radius: 4px;
        }
        pre {
            padding: 15px;
            overflow-x: auto;
            margin-bottom: 20px;
        }
        code {
            padding: 2px 4px;
        }
        .video-container {
            position: relative;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            height: 0;
            overflow: hidden;
            margin-bottom: 20px;
            background-color: #333a47;
            border-radius: 8px;
        }
        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
        }
        .footer-cta {
            margin-top: 40px;
            text-align: center;
        }
        .cta-button {
            display: inline-block;
            background-color: #ff5722;
            color: #ffffff;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1.2rem;
        }
    </style>
    <script>
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
        }
    </script>
</head>
<body>
    <div class="container">
        <!-- Navigation -->
        <a href="../modules/module-1-binary-trees-i.html" class="back-button">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="20" height="20">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
            Back to Module 1
        </a>

        <!-- Header Section -->
        <h1>Binary Trees I: Guided Project</h1>
        <p class="intro-text">
            Master the fundamentals of Binary Search Trees through hands-on implementation and practical exercises.
        </p>

        <!-- Main Navigation Tabs -->
        <div class="tabs">
            <button class="tab active" data-tab="overview-tab" onclick="switchTab('overview-tab')">Overview</button>
            <button class="tab" data-tab="implementation-tab" onclick="switchTab('implementation-tab')">Implementation Guide</button>
            <button class="tab" data-tab="exercises-tab" onclick="switchTab('exercises-tab')">Practice Exercises</button>
        </div>

        <!-- Tab Contents -->
        <div class="tab-contents">
            <!-- Overview Tab -->
            <div id="overview-tab" class="tab-content active">
                <div class="card">
                    <h2>Binary Search Tree Fundamentals</h2>
                    <p>
                        Binary Search Trees (BST) are fundamental data structures that provide efficient operations for insertion, deletion, and searching. In this guided project, you'll learn how to implement these core operations while maintaining the BST property.
                    </p>
                    <div class="grid">
                        <div class="feature-box">
                            <h3>Key Concepts</h3>
                            <ul class="feature-list">
                                <li class="feature-item">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <span>BST Property: Left subtree values < node value < right subtree values</span>
                                </li>
                                <li class="feature-item">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <span>Node structure: value, left child, right child</span>
                                </li>
                                <li class="feature-item">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <span>Time complexity: O(log n) average case operations</span>
                                </li>
                            </ul>
                        </div>
                        <div class="feature-box">
                            <h3>Learning Objectives</h3>
                            <ul class="feature-list">
                                <li class="feature-item">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <span>Implement BST insertion operation</span>
                                </li>
                                <li class="feature-item">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <span>Understand recursive tree traversal</span>
                                </li>
                                <li class="feature-item">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <span>Maintain BST properties during operations</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Implementation Guide Tab -->
            <div id="implementation-tab" class="tab-content">
                <div class="card">
                    <h2>Inserting Values into a Binary Search Tree</h2>
                    
                    <!-- Video Section -->
                    <div class="video-container">
                        <iframe title="Insert a Value Into a Binary Search Tree Video" 
                                src="https://fast.wistia.net/embed/iframe/vjv1s9hufq"
                                allow="autoplay; fullscreen" 
                                scrolling="no"
                                class="wistia_embed">
                        </iframe>
                    </div>

                    <div class="feature-box">
                        <h3>Implementation Steps</h3>
                        <ol>
                            <li class="step-item">
                                <div class="step-number">1</div>
                                <div class="step-content">
                                    <h4>Create Node Class</h4>
                                    <p>Define a Node class with value, left, and right properties</p>
                                    <pre><code>public class Node {
    private int value;
    private Node left;
    private Node right;
    
    public Node(int value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
    
    // Getters and setters
    public int getValue() { return value; }
    public Node getLeft() { return left; }
    public Node getRight() { return right; }
    public void setLeft(Node left) { this.left = left; }
    public void setRight(Node right) { this.right = right; }
}</code></pre>
                                </div>
                            </li>
                            <li class="step-item">
                                <div class="step-number">2</div>
                                <div class="step-content">
                                    <h4>Implement BST Class</h4>
                                    <p>Create a Binary Search Tree class with a root node reference</p>
                                    <pre><code>public class BinarySearchTree {
    private Node root;
    
    public BinarySearchTree() {
        this.root = null;
    }
    
    // Public insert method
    public void insert(int value) {
        root = insertRecursive(root, value);
    }
    
    // Private recursive helper
    private Node insertRecursive(Node current, int value) {
        // Base case: If current is null, create a new node
        if (current == null) {
            return new Node(value);
        }
        
        // Recursive case: Traverse left or right
        if (value < current.getValue()) {
            current.setLeft(insertRecursive(current.getLeft(), value));
        } else if (value > current.getValue()) {
            current.setRight(insertRecursive(current.getRight(), value));
        }
        
        // Return the (possibly modified) node reference
        return current;
    }
}</code></pre>
                                </div>
                            </li>
                            <li class="step-item">
                                <div class="step-number">3</div>
                                <div class="step-content">
                                    <h4>Handle Edge Cases</h4>
                                    <p>Consider how to handle duplicates, depending on your requirements:</p>
                                    <pre><code>// Option 1: Ignore duplicates (shown above)
// Option 2: Allow duplicates (e.g., go to the right)
if (value >= current.getValue()) {
    current.setRight(insertRecursive(current.getRight(), value));
}

// Option 3: Track frequency with a count field
if (value == current.getValue()) {
    current.incrementCount(); // Assuming a count field exists
    return current;
}</code></pre>
                                </div>
                            </li>
                        </ol>
                    </div>

                    <div class="feature-box">
                        <h3>Visual Explanation: Insertion Process</h3>
                        <p>Let's visualize how insertion works by inserting values [10, 5, 15, 3, 7, 12, 17] in order:</p>
                        
                        <h4>1. Insert 10 (root)</h4>
                        <pre><code>       10</code></pre>
                        
                        <h4>2. Insert 5 (less than 10, go left)</h4>
                        <pre><code>       10
       /
      5</code></pre>
                        
                        <h4>3. Insert 15 (greater than 10, go right)</h4>
                        <pre><code>       10
       / \
      5   15</code></pre>
                        
                        <h4>4. Insert 3 (less than 10, go left; less than 5, go left)</h4>
                        <pre><code>       10
       / \
      5   15
     /
    3</code></pre>
                        
                        <h4>5. Insert 7 (less than 10, go left; greater than 5, go right)</h4>
                        <pre><code>       10
       / \
      5   15
     / \
    3   7</code></pre>
                        
                        <h4>6. Final tree after inserting 12 and 17</h4>
                        <pre><code>       10
       / \
      5   15
     / \  / \
    3   7 12 17</code></pre>
                        
                        <p>Notice how each insertion follows the BST property: values less than a node go to its left, values greater go to its right.</p>
                    </div>

                    <div class="feature-box">
                        <h3>Performance Considerations</h3>
                        <ul>
                            <li><strong>Time Complexity:</strong> O(log n) for balanced trees, but can degrade to O(n) in worst case (when tree becomes a linked list)</li>
                            <li><strong>Space Complexity:</strong> O(h) where h is the height of the tree (due to recursion stack)</li>
                            <li><strong>Balancing:</strong> Standard BSTs can become unbalanced. Consider self-balancing trees like AVL or Red-Black trees for guaranteed O(log n) operations.</li>
                        </ul>
                    </div>

                    <div class="feature-box">
                        <h3>Implementation Variations</h3>
                        <h4>Iterative Insert (Non-Recursive)</h4>
                        <pre><code>public void insertIterative(int value) {
    Node newNode = new Node(value);
    
    // If tree is empty, set new node as root
    if (root == null) {
        root = newNode;
        return;
    }
    
    // Traverse to find the insertion point
    Node current = root;
    Node parent = null;
    
    while (true) {
        parent = current;
        
        if (value < current.getValue()) {
            current = current.getLeft();
            if (current == null) {
                parent.setLeft(newNode);
                return;
            }
        } else {
            current = current.getRight();
            if (current == null) {
                parent.setRight(newNode);
                return;
            }
        }
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <!-- Practice Exercises Tab -->
            <div id="exercises-tab" class="tab-content">
                <div class="card">
                    <h2>Practice Exercises</h2>
                    <div class="feature-box">
                        <h3>Exercise 1: Basic Insertion</h3>
                        <p>
                            Implement the insert method for a Binary Search Tree that maintains the BST property.
                        </p>
                        <pre><code>public void insert(int value) {
    // Your implementation here
}</code></pre>
                    </div>

                    <div class="feature-box">
                        <h3>Exercise 2: Tree Validation</h3>
                        <p>
                            Write a method to verify if a binary tree satisfies the BST property.
                        </p>
                        <pre><code>public boolean isValidBST() {
    return isValidBSTHelper(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
}

private boolean isValidBSTHelper(Node node, int min, int max) {
    // Your implementation here
    // Hint: Each node's value must be within the valid range for its position
}</code></pre>
                    </div>

                    <div class="feature-box">
                        <h3>Exercise 3: Tree Traversal</h3>
                        <p>
                            Implement in-order traversal to print all values in sorted order.
                        </p>
                        <pre><code>public void inOrderTraversal() {
    inOrderTraversalHelper(root);
}

private void inOrderTraversalHelper(Node node) {
    // Your implementation here
    // Hint: Visit left subtree, then node, then right subtree
}</code></pre>
                    </div>

                    <div class="feature-box">
                        <h3>Exercise 4: Find Min and Max Values</h3>
                        <p>
                            Implement methods to find the minimum and maximum values in the BST.
                        </p>
                        <pre><code>public int findMin() {
    // Your implementation here
    // Hint: Keep going left until you can't go anymore
}

public int findMax() {
    // Your implementation here
    // Hint: Keep going right until you can't go anymore
}</code></pre>
                    </div>

                    <div class="feature-box">
                        <h3>Exercise 5: Advanced - Tree Height</h3>
                        <p>
                            Implement a method to calculate the height of the tree (the length of the longest path from root to leaf).
                        </p>
                        <pre><code>public int height() {
    return heightHelper(root);
}

private int heightHelper(Node node) {
    // Your implementation here
    // Hint: Use recursion to find the maximum height of the left and right subtrees
}</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer Section -->
        <div class="footer-cta">
            <div class="cta-button">
                Ready to implement your first Binary Search Tree?
            </div>
        </div>
    </div>
</body>
</html>