<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Practice Binary Trees and Searching</title>
<meta name="identifier" content="ga71a6668516e0f3001cc11d4f29ddbfc"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
<style>
  .objectives-section {
    margin-bottom: 20px;
    padding: 10px;
    border-left: 3px solid #93005a;
    background-color: #f9f9f9;
  }
  
  .content-section {
    margin-bottom: 20px;
  }
  
  .code-block {
    background-color: #f5f5f5;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-family: monospace;
    white-space: pre;
    overflow-x: auto;
  }
  
  .leetcode-link {
    color: #FF8C00;
    text-decoration: none;
  }
  
  .leetcode-link:hover {
    text-decoration: underline;
  }
</style>
</head>
<body>
<div class="objectives-section">
  <h2>Module Objectives</h2>
  <h3>Binary Trees</h3>
  <p>Upon completion of the binary trees module, you will be able to:</p>
  <ul>
    <li>Understand the layout and structure of a binary tree</li>
    <li>Distinguish between a binary tree and a binary search tree (BST)</li>
    <li>Analyze the time complexity of searching and inserting into a binary search tree</li>
    <li>Implement a binary search tree with basic operations</li>
  </ul>
  
  <h3>Searching Algorithms</h3>
  <p>Upon completion of the searching module, you will be able to:</p>
  <ul>
    <li>Implement a linear search algorithm</li>
    <li>Implement a binary search algorithm</li>
    <li>Understand the time complexity differences between linear and binary search</li>
    <li>Apply these searching algorithms to solve practical problems</li>
  </ul>
</div>

<div class="content-section">
  <h3>Binary Tree Basics</h3>
  <p>A binary tree is a hierarchical data structure where each node has at most two children, referred to as left and right child nodes.</p>
  
  <h4>Key Terminology:</h4>
  <ul>
    <li><strong>Root:</strong> The topmost node of the tree</li>
    <li><strong>Parent/Child:</strong> Relationship between connected nodes</li>
    <li><strong>Leaf:</strong> A node with no children</li>
    <li><strong>Height:</strong> The length of the longest path from root to leaf</li>
    <li><strong>Depth:</strong> The length of the path from root to a specific node</li>
  </ul>
  
  <div class="code-block">
// Binary Tree Node
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

// Binary Search Tree implementation
class BinarySearchTree {
  constructor() {
    this.root = null;
  }
  
  // Other methods will be implemented below
}
  </div>
</div>

<div class="content-section">
  <h3>Binary Search Tree (BST)</h3>
  <p>A Binary Search Tree is a special type of binary tree where:</p>
  <ul>
    <li>The left subtree of a node contains only nodes with values less than the node's value</li>
    <li>The right subtree of a node contains only nodes with values greater than the node's value</li>
    <li>Both the left and right subtrees are also BSTs</li>
  </ul>
  
  <h4>BST Search Implementation:</h4>
  <div class="code-block">
// Search for a value in BST
search(value) {
  return this._searchNode(this.root, value);
}

_searchNode(node, value) {
  // Base cases: empty tree or found the value
  if (node === null) return null;
  if (node.value === value) return node;
  
  // Recursive cases
  if (value < node.value) {
    return this._searchNode(node.left, value);
  } else {
    return this._searchNode(node.right, value);
  }
}
  </div>
  
  <h4>BST Insert Implementation:</h4>
  <div class="code-block">
// Insert a value into BST
insert(value) {
  const newNode = new Node(value);
  
  if (this.root === null) {
    this.root = newNode;
    return this;
  }
  
  this._insertNode(this.root, newNode);
  return this;
}

_insertNode(node, newNode) {
  // If value is less than node's value, go left
  if (newNode.value < node.value) {
    if (node.left === null) {
      node.left = newNode;
    } else {
      this._insertNode(node.left, newNode);
    }
  } 
  // If value is greater than node's value, go right
  else {
    if (node.right === null) {
      node.right = newNode;
    } else {
      this._insertNode(node.right, newNode);
    }
  }
}
  </div>
</div>

<div class="content-section">
  <h3>Searching Algorithms</h3>
  
  <h4>Linear Search</h4>
  <p>Linear search is the simplest searching algorithm that checks each element of the array one by one until the target is found or the array is exhausted.</p>
  
  <div class="code-block">
// Linear Search implementation
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i; // Return index if found
    }
  }
  return -1; // Return -1 if not found
}

// Time Complexity: O(n)
// Space Complexity: O(1)
  </div>
  
  <h4>Binary Search</h4>
  <p>Binary search is a divide-and-conquer algorithm that works on sorted arrays by repeatedly dividing the search interval in half.</p>
  
  <div class="code-block">
// Binary Search implementation (iterative)
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    // Check if target is at mid
    if (arr[mid] === target) {
      return mid;
    }
    
    // If target is greater, ignore left half
    if (arr[mid] < target) {
      left = mid + 1;
    } 
    // If target is smaller, ignore right half
    else {
      right = mid - 1;
    }
  }
  
  // Target not found
  return -1;
}

// Time Complexity: O(log n)
// Space Complexity: O(1)
  </div>
  
  <h4>Recursive Binary Search</h4>
  <div class="code-block">
// Binary Search implementation (recursive)
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
  // Base case: element not found
  if (left > right) {
    return -1;
  }
  
  const mid = Math.floor((left + right) / 2);
  
  // Found the target
  if (arr[mid] === target) {
    return mid;
  }
  
  // Recursive cases
  if (arr[mid] > target) {
    return binarySearchRecursive(arr, target, left, mid - 1);
  } else {
    return binarySearchRecursive(arr, target, mid + 1, right);
  }
}
  </div>
</div>

<p><strong>Now it's time to practice what you learned!</strong></p>
<p>You should have already created your Code Signal account. If you have not done so yet, please follow these instructions <a title="What is CodeSignal and How to Create Your Account" href="$WIKI_REFERENCE$/pages/g0f9edee9d9bad727f053555cc74965dd" data-api-endpoint="https://bloomtech.instructure.com/api/v1/courses/2482/pages/what-is-codesignal-and-how-to-create-your-account" data-api-returntype="Page">What is CodeSignal and How to Create Your Account</a>.</p>
<p><em>Tip:&nbsp; Before you dive into the practice tasks, revisit the core competency and guided project videos in this sprint.</em></p>
<hr>
<p>Complete these tasks in CodeSignal:</p>
<p><a class="leetcode-link" href="https://app.codesignal.com/public-test/azqEu2QDZfBwsuakz/EJsRhkstAmZuDQ" target="_blank" rel="noopener">ACS2M4</a></p>
<p><a class="leetcode-link" href="https://app.codesignal.com/public-test/dfGtZxm6289jjD8ns/snHo2H5N2PMKi8" target="_blank" rel="noopener">ACS2M5</a></p>
<p><a class="leetcode-link" href="https://app.codesignal.com/public-test/d8ZaBTiF7PPmG8oNB/Spk5zCuFnKN3Kh" target="_blank" rel="noopener">ACS2M6</a></p>
<p>Bonus - Once you have finished the above tasks, here is an extra <a class="leetcode-link" href="https://app.codesignal.com/public-test/cMQgEKEDbDZeCBaac/M9XsxhgMiQ7Eiv" target="_blank" rel="noopener">challenge</a>!</p>
<hr>
<ol>
<li>Login to CodeSignal</li>
<li>Click on the task links above</li>
<li>Select your preferred language</li>
<li>Click on NEXT to begin</li>
<li>Agree with the Terms and Pledges and click START</li>
</ol>
<hr>
<p>Once all the questions for each task are completed in Code Signal, click on&nbsp;<strong>Finish the Test</strong>.</p>
</body>
</html>