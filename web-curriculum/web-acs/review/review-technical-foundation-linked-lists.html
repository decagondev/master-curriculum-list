<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Review Technical Foundation: Linked Lists</title>
<meta name="identifier" content="gca29d0429465019e665fee3c6a311368"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
<style>
  .code-block {
    background-color: #f5f5f5;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-family: monospace;
    white-space: pre;
    overflow-x: auto;
  }
  
  .leetcode-link {
    color: #FF8C00;
    text-decoration: none;
  }
  
  .leetcode-link:hover {
    text-decoration: underline;
  }
  
  .concept-section {
    margin-bottom: 20px;
    padding: 10px;
    border-left: 3px solid #93005a;
    background-color: #f9f9f9;
  }
  
  .video-description {
    margin-top: 10px;
    margin-bottom: 15px;
  }
</style>
</head>
<body>
<h2>Utilize Linked Lists with Objects</h2>

<div class="concept-section">
  <p>Linked lists are fundamental data structures that consist of nodes connected through references. Unlike arrays, linked lists provide dynamic memory allocation and efficient insertion/deletion operations. Understanding linked lists is crucial for technical interviews and building more complex data structures.</p>
  
  <p>Upon completion of this review section, you will be able to:</p>
  <ul>
    <li>Understand how object references work in JavaScript</li>
    <li>Implement a basic linked list data structure</li>
    <li>Perform key operations: insertion, deletion, and traversal</li>
    <li>Analyze the time and space complexity of linked list operations</li>
  </ul>
</div>

<h3><strong>Object References JS</strong></h3>
<p><iframe class="wistia_embed" title="Web_s12 M3 (Core Competency 1) Object References JS Video" src="https://fast.wistia.net/embed/iframe/nw0hp8x87c" width="640" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe></p>

<div class="video-description">
  <p>Object references are the foundation of linked lists in JavaScript. Understanding how variables reference objects rather than contain them is crucial for working with linked data structures.</p>
  
  <div class="code-block">
// Example of object references in JavaScript
let obj1 = { value: 10 };
let obj2 = obj1;  // obj2 references the same object

obj2.value = 20;
console.log(obj1.value);  // Outputs: 20

// Creating a new object breaks the reference
obj2 = { value: 30 };
console.log(obj1.value);  // Still outputs: 20
  </div>
  
  <p>Understanding these reference concepts is essential when manipulating linked list nodes, as changing one node can affect others through the reference chain.</p>
</div>

<h3><strong>Linked List Intro JS</strong></h3>
<p><iframe class="wistia_embed" title="Linked List Intro Video" src="https://fast.wistia.net/embed/iframe/ghbmfm90f2" width="640" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe></p>

<div class="video-description">
  <p>Linked lists consist of nodes where each node contains data and a reference (or "link") to the next node in the sequence. This introduction covers the core concepts and structure of linked lists.</p>
  
  <h4>Types of Linked Lists:</h4>
  <ul>
    <li><strong>Singly Linked List:</strong> Each node points to the next node</li>
    <li><strong>Doubly Linked List:</strong> Each node points to both next and previous nodes</li>
    <li><strong>Circular Linked List:</strong> Last node points back to the first node</li>
  </ul>
  
  <div class="code-block">
// Basic Node structure for a singly linked list
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

// Basic LinkedList class
class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
}
  </div>
  
  <p><strong>Time Complexity Comparison:</strong></p>
  <ul>
    <li>Access: O(n) - must traverse from head</li>
    <li>Insertion at beginning: O(1)</li>
    <li>Deletion at beginning: O(1)</li>
    <li>Insertion/Deletion in middle or end: O(n)</li>
  </ul>
  
  <p>Practice with this <a class="leetcode-link" href="https://leetcode.com/problems/design-linked-list/" target="_blank" rel="noopener">Design Linked List</a> problem on LeetCode.</p>
</div>

<h3><strong>Linked List Classes JS</strong></h3>
<p><strong><iframe class="wistia_embed" title="Web_s12 M3 (Core Competency 1) Linked List Classes JS Video" src="https://fast.wistia.net/embed/iframe/aqd9jcuxf6" width="640" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe></strong></p>

<div class="video-description">
  <p>This video demonstrates how to implement linked list functionality using JavaScript classes. Object-oriented programming principles help organize the code and create a clean API for working with linked lists.</p>
  
  <div class="code-block">
// Complete LinkedList implementation
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  
  // Add to the end of the list
  append(value) {
    const newNode = new Node(value);
    
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode;
      this.tail = newNode;
    }
    
    this.length++;
    return this;
  }
  
  // Add to the beginning of the list
  prepend(value) {
    const newNode = new Node(value);
    
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.next = this.head;
      this.head = newNode;
    }
    
    this.length++;
    return this;
  }
  
  // Print the list (for debugging)
  printList() {
    const array = [];
    let currentNode = this.head;
    
    while (currentNode) {
      array.push(currentNode.value);
      currentNode = currentNode.next;
    }
    
    return array;
  }
}
  </div>
  
  <p>Challenge yourself with these LeetCode problems:</p>
  <ul>
    <li><a class="leetcode-link" href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">Merge Two Sorted Lists</a></li>
    <li><a class="leetcode-link" href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle</a></li>
  </ul>
</div>

<h3><strong>Linked List Build - Part 1 - Understand JS</strong></h3>
<p><strong><iframe class="wistia_embed" title="Web_s12 M3 (Core Competency 1) Linked List Build - Part 1 - Understand JS Video" src="https://fast.wistia.net/embed/iframe/2gqodhtwjr" width="640" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe></strong></p>

<div class="video-description">
  <p>This video focuses on understanding the problem before implementing a linked list. Key considerations include:</p>
  <ul>
    <li>Identifying what functionality is needed</li>
    <li>Understanding the constraints and requirements</li>
    <li>Breaking down the problem into manageable components</li>
  </ul>
  
  <p>When developing linked list solutions, first ensure you understand:</p>
  <ul>
    <li>The data structure's behavior</li>
    <li>Edge cases (empty list, single element, etc.)</li>
    <li>Performance requirements</li>
  </ul>
</div>

<h3><strong>Linked List Build - Part 2 - Plan JS</strong></h3>
<p><strong><iframe class="wistia_embed" title="Web_s12 M3 (Core Competency 1) Linked List Build - Part 2 - Plan JS Video" src="https://fast.wistia.net/embed/iframe/j3z2n526bq" width="640" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe></strong></p>

<div class="video-description">
  <p>Planning is crucial for efficiently implementing a linked list. This video covers:</p>
  <ul>
    <li>Designing the API and method signatures</li>
    <li>Determining what properties the list needs to track</li>
    <li>Planning how to handle edge cases</li>
  </ul>
  
  <div class="code-block">
// Example planning pseudocode for insert method
/*
insertAt(index, value):
  1. Validate index is within bounds (0 to length)
  2. Create new node with value
  3. If index is 0, use prepend method
  4. If index is length, use append method
  5. Otherwise:
     a. Traverse to node at index-1
     b. Set newNode.next to current node's next
     c. Set current node's next to newNode
     d. Increment length
  6. Return updated list
*/
  </div>
</div>

<h3><strong>Linked List Build - Part 3 - Execute JS</strong></h3>
<p><strong><iframe class="wistia_embed" title="Web_s12 M3 (Core Competency 1) Linked List Build - Part 3 - Execute JS Video" src="https://fast.wistia.net/embed/iframe/w3hivphbht" width="640" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe></strong></p>

<div class="video-description">
  <p>This video demonstrates implementing the core functionality of a linked list, focusing on common operations:</p>
  
  <div class="code-block">
// Implementation of key linked list methods
class LinkedList {
  // ... constructor and previous methods ...
  
  // Get node at specific index
  getNodeAt(index) {
    if (index &lt; 0 || index &gt;= this.length) return null;
    
    let current = this.head;
    for (let i = 0; i &lt; index; i++) {
      current = current.next;
    }
    return current;
  }
  
  // Insert at specific position
  insertAt(index, value) {
    if (index &lt; 0 || index &gt; this.length) return this;
    if (index === 0) return this.prepend(value);
    if (index === this.length) return this.append(value);
    
    const newNode = new Node(value);
    const prevNode = this.getNodeAt(index - 1);
    
    newNode.next = prevNode.next;
    prevNode.next = newNode;
    this.length++;
    
    return this;
  }
  
  // Remove at specific position
  removeAt(index) {
    if (index &lt; 0 || index &gt;= this.length) return null;
    
    // Remove head
    if (index === 0) {
      const removed = this.head;
      this.head = this.head.next;
      
      // If we removed the last item
      if (this.length === 1) {
        this.tail = null;
      }
      
      this.length--;
      return removed.value;
    }
    
    // Remove other position
    const prevNode = this.getNodeAt(index - 1);
    const removed = prevNode.next;
    
    prevNode.next = removed.next;
    
    // If we removed the tail
    if (index === this.length - 1) {
      this.tail = prevNode;
    }
    
    this.length--;
    return removed.value;
  }
}
  </div>
  
  <p>Challenge yourself with these linked list operations on LeetCode:</p>
  <ul>
    <li><a class="leetcode-link" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">Remove Nth Node From End of List</a></li>
    <li><a class="leetcode-link" href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a></li>
  </ul>
</div>

<h3><strong>Linked List Build - Part 4 - Reflect JS</strong></h3>
<p><strong><iframe class="wistia_embed" title="Web_s12 M3 (Core Competency 1) Linked List Build - Part 4 - Reflect JS Video" src="https://fast.wistia.net/embed/iframe/vwubiabqlm" width="640" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe></strong></p>

<div class="video-description">
  <p>Reflection is an important step in programming that helps improve your understanding and skills. This video covers:</p>
  <ul>
    <li>Evaluating the implementation against requirements</li>
    <li>Identifying potential optimizations</li>
    <li>Analyzing the time and space complexity</li>
    <li>Considering alternative approaches</li>
  </ul>
  
  <h4>Common Linked List Interview Questions:</h4>
  <ul>
    <li>Finding the middle element</li>
    <li>Detecting cycles</li>
    <li>Reversing a linked list</li>
    <li>Merging sorted lists</li>
  </ul>
  
  <div class="code-block">
// Example: Finding the middle node using the "tortoise and hare" approach
function findMiddle(linkedList) {
  if (!linkedList.head) return null;
  
  let slow = linkedList.head;
  let fast = linkedList.head;
  
  // Fast pointer moves twice as fast as slow
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }
  
  // When fast reaches the end, slow is at the middle
  return slow;
}
  </div>
  
  <p>Note: Previously, this course referenced the CodeSignal Arcade for practice, which is no longer available. The LeetCode problems linked throughout this page follow the same principles and are an excellent alternative for practicing linked list operations and preparing for technical interviews.</p>
  
  <p>Additional challenging linked list problems on LeetCode:</p>
  <ul>
    <li><a class="leetcode-link" href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">Palindrome Linked List</a></li>
    <li><a class="leetcode-link" href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">Intersection of Two Linked Lists</a></li>
    <li><a class="leetcode-link" href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">Sort List</a></li>
  </ul>
</div>

</body>
</html>