<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Module 3: Introduction to Recursion</title>
<meta name="identifier" content="g808b234207be23fe4a1c059b7400a1f7"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
<style>
  .code-block {
    background-color: #f5f5f5;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-family: monospace;
    white-space: pre;
    overflow-x: auto;
  }
  
  .leetcode-link {
    color: #FF8C00;
    text-decoration: none;
  }
  
  .leetcode-link:hover {
    text-decoration: underline;
  }
  
  .objectives-section {
    margin-bottom: 20px;
    padding: 10px;
    border-left: 3px solid #93005a;
    background-color: #f9f9f9;
  }
  
  .content-section {
    margin-bottom: 20px;
  }
</style>
</head>
<body>
<div class="objectives-section">
  <h2>Module Objectives</h2>
  <p>Upon completion of this module, you will be able to:</p>
  <ul>
    <li>Identify a recursive problem and determine when recursion is appropriate</li>
    <li>Define a recursive solution by breaking down a problem into smaller, similar problems</li>
    <li>Understand base cases and recursive cases in recursive functions</li>
    <li>Trace recursive function calls to understand execution flow</li>
    <li>Apply recursive solutions to linked list and tree problems</li>
    <li>Analyze the time and space complexity of recursive algorithms</li>
  </ul>
</div>

<h3><strong>Recursion Basics</strong></h3>
<p><iframe class="wistia_embed" title="s17M3 JavaScript CC1 Recursion Basics Video" src="https://fast.wistia.net/embed/iframe/dy4ey5vozu" width="640" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe></p>

<div class="content-section">
  <h4>What is Recursion?</h4>
  <p>Recursion is a programming technique where a function calls itself to solve a problem. It's particularly useful for problems that can be broken down into smaller instances of the same problem.</p>
  
  <p><strong>Key Components of Recursion:</strong></p>
  <ul>
    <li><strong>Base Case:</strong> A condition that stops the recursion</li>
    <li><strong>Recursive Case:</strong> The function calling itself with a smaller/simpler input</li>
    <li><strong>Progress Toward Base Case:</strong> Ensuring the recursion will eventually terminate</li>
  </ul>
  
  <h4>Simple Example: Factorial</h4>
  <div class="code-block">
// Recursive factorial function
function factorial(n) {
  // Base case
  if (n === 0 || n === 1) {
    return 1;
  }
  // Recursive case
  return n * factorial(n - 1);
}

// Example usage
console.log(factorial(5)); // 120 (5 * 4 * 3 * 2 * 1)
  </div>
  
  <h4>Recursive Function Tracing</h4>
  <p>Understanding how recursive calls stack up is crucial:</p>
  <div class="code-block">
// Tracing factorial(5):
factorial(5)
→ 5 * factorial(4)
  → 5 * (4 * factorial(3))
    → 5 * (4 * (3 * factorial(2)))
      → 5 * (4 * (3 * (2 * factorial(1))))
        → 5 * (4 * (3 * (2 * 1)))
      → 5 * (4 * (3 * 2))
    → 5 * (4 * 6)
  → 5 * 24
→ 120
  </div>
</div>

<div class="content-section">
  <h4>More Recursive Examples</h4>
  
  <h5>1. Fibonacci Sequence</h5>
  <div class="code-block">
// Recursive Fibonacci (inefficient but illustrative)
function fibonacci(n) {
  // Base cases
  if (n <= 0) return 0;
  if (n === 1) return 1;
  
  // Recursive case
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// Example usage
console.log(fibonacci(6)); // 8
  </div>
  
  <p>Note: The simple recursive implementation of Fibonacci has exponential time complexity O(2^n). For efficiency, you'd use dynamic programming or memoization:</p>
  
  <div class="code-block">
// Fibonacci with memoization
function fibonacciMemo(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 0) return 0;
  if (n === 1) return 1;
  
  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
  return memo[n];
}

// Example usage
console.log(fibonacciMemo(50)); // Much faster for large inputs
  </div>
  
  <h5>2. Linked List Recursion</h5>
  <div class="code-block">
// Node definition
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

// Find length of linked list recursively
function getLength(head) {
  // Base case: empty list
  if (head === null) {
    return 0;
  }
  
  // Recursive case: count this node plus the rest
  return 1 + getLength(head.next);
}

// Reverse a linked list recursively
function reverseList(head) {
  // Base cases: empty list or only one node
  if (head === null || head.next === null) {
    return head;
  }
  
  // Recursive case
  const newHead = reverseList(head.next);
  
  // Reverse the pointers
  head.next.next = head;
  head.next = null;
  
  return newHead;
}
  </div>
</div>

<div class="content-section">
  <h4>Recursion vs. Iteration</h4>
  <p>It's important to understand when to use recursion versus iterative approaches:</p>
  
  <table border="1" style="border-collapse: collapse; width: 100%;">
    <tr>
      <th style="padding: 8px;">Aspect</th>
      <th style="padding: 8px;">Recursion</th>
      <th style="padding: 8px;">Iteration</th>
    </tr>
    <tr>
      <td style="padding: 8px;">Memory Usage</td>
      <td style="padding: 8px;">Uses call stack (higher memory overhead)</td>
      <td style="padding: 8px;">Typically uses less memory</td>
    </tr>
    <tr>
      <td style="padding: 8px;">Code Clarity</td>
      <td style="padding: 8px;">Often more elegant and readable for certain problems</td>
      <td style="padding: 8px;">May be more straightforward for simple problems</td>
    </tr>
    <tr>
      <td style="padding: 8px;">Performance</td>
      <td style="padding: 8px;">Can be slower due to function call overhead</td>
      <td style="padding: 8px;">Usually faster</td>
    </tr>
    <tr>
      <td style="padding: 8px;">Stack Overflow Risk</td>
      <td style="padding: 8px;">Possible with deep recursion</td>
      <td style="padding: 8px;">Not an issue</td>
    </tr>
    <tr>
      <td style="padding: 8px;">Best For</td>
      <td style="padding: 8px;">Tree traversals, divide-and-conquer algorithms</td>
      <td style="padding: 8px;">Simple loops, performance-critical code</td>
    </tr>
  </table>
  
  <h5>Iterative vs. Recursive Factorial Example</h5>
  <div class="code-block">
// Recursive
function factorialRecursive(n) {
  if (n === 0 || n === 1) return 1;
  return n * factorialRecursive(n - 1);
}

// Iterative
function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}
  </div>
</div>

<div class="content-section">
  <h4>Common Recursion Pitfalls</h4>
  <ul>
    <li><strong>Missing Base Case:</strong> Leads to infinite recursion and stack overflow</li>
    <li><strong>Inefficient Overlapping Subproblems:</strong> Can make recursion exponentially slow</li>
    <li><strong>Stack Overflow:</strong> With deeply nested recursion</li>
    <li><strong>Unnecessary Recursion:</strong> When an iterative solution is simpler</li>
  </ul>
  
  <h4>Techniques to Improve Recursive Solutions</h4>
  <ul>
    <li><strong>Memoization:</strong> Store results of subproblems to avoid redundant calculations</li>
    <li><strong>Tail Recursion:</strong> Special form where recursive call is the last operation</li>
    <li><strong>Trampolining:</strong> Technique to avoid stack overflow by simulating recursion</li>
  </ul>
</div>

<h3>Practice with LeetCode Problems</h3>

<p>Note: Previously, this course referenced the CodeSignal Arcade for practice, which is no longer available. The LeetCode problems below follow the same principles and are an excellent alternative for practicing recursion.</p>

<h4>Basic Recursion Problems:</h4>
<ul>
  <li><a href="https://leetcode.com/problems/fibonacci-number/" class="leetcode-link" target="_blank" rel="noopener">Fibonacci Number</a> - Classic recursion example</li>
  <li><a href="https://leetcode.com/problems/climbing-stairs/" class="leetcode-link" target="_blank" rel="noopener">Climbing Stairs</a> - Similar to Fibonacci but with a practical context</li>
  <li><a href="https://leetcode.com/problems/powx-n/" class="leetcode-link" target="_blank" rel="noopener">Pow(x, n)</a> - Implement power function using recursion</li>
</ul>

<h4>Recursive List Problems:</h4>
<ul>
  <li><a href="https://leetcode.com/problems/reverse-linked-list/" class="leetcode-link" target="_blank" rel="noopener">Reverse Linked List</a> - Practice recursive linked list manipulation</li>
  <li><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" class="leetcode-link" target="_blank" rel="noopener">Swap Nodes in Pairs</a> - Intermediate linked list recursion</li>
  <li><a href="https://leetcode.com/problems/merge-two-sorted-lists/" class="leetcode-link" target="_blank" rel="noopener">Merge Two Sorted Lists</a> - Can be solved elegantly with recursion</li>
</ul>

<h4>Tree Recursion:</h4>
<ul>
  <li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" class="leetcode-link" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a> - Simple tree recursion</li>
  <li><a href="https://leetcode.com/problems/same-tree/" class="leetcode-link" target="_blank" rel="noopener">Same Tree</a> - Compare two trees recursively</li>
  <li><a href="https://leetcode.com/problems/path-sum/" class="leetcode-link" target="_blank" rel="noopener">Path Sum</a> - Find paths in a tree recursively</li>
</ul>

<hr>
</body>
</html>