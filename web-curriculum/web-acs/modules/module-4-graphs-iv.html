<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Module 4: Graphs IV</title>
<meta name="identifier" content="gb3a42bb278d1626da4f71f93661971b2"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
<style>
  .code-block {
    background-color: #f5f5f5;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-family: monospace;
    white-space: pre;
    overflow-x: auto;
  }
  
  .leetcode-link {
    color: #FF8C00;
    text-decoration: none;
  }
  
  .leetcode-link:hover {
    text-decoration: underline;
  }
  
  .objectives-section {
    margin-bottom: 20px;
    padding: 10px;
    border-left: 3px solid #93005a;
    background-color: #f9f9f9;
  }
  
  .content-section {
    margin-bottom: 20px;
  }

  /* Video container styles */
  .video-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    margin: 15px 0;
  }
  
  .video-wrapper {
    height: 100%;
    left: 0;
    position: absolute;
    top: 0;
    width: 100%;
  }

  /* Table styles */
  .data-table {
    border-collapse: collapse;
    width: 100%;
  }

  .table-header {
    padding: 8px;
    background-color: #f0f0f0;
  }

  .table-cell {
    padding: 8px;
    border: 1px solid #ddd;
  }
</style>
</head>
<body>
<div class="objectives-section">
  <h2>Module Objectives</h2>
  <p>Upon completion of this module you will be able to:</p>
  <ul>
    <li>Understand advanced graph traversal techniques including Depth-First Traversal (DFT)</li>
    <li>Implement DFT in both recursive and iterative forms</li>
    <li>Apply DFT to solve graph-based problems</li>
    <li>Compare DFT with other graph traversal algorithms</li>
    <li>Analyze the time and space complexity of graph traversal methods</li>
  </ul>
</div>

<h3><strong>Depth-First Traversal (DFT)</strong></h3>
<p>
<div class="video-container">
  <div class="video-wrapper">
    <iframe class="wistia_embed" title="s20M1 JavaScript CC4 Graph DFT Video" src="https://fast.wistia.net/embed/iframe/79o1ig55qk" width="100%" height="100%" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe>
  </div>
</div>
</p>

<div class="content-section">
  <h4>Understanding Depth-First Traversal</h4>
  <p>Depth-First Traversal (DFT) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It uses the principle of recursion and backtracking or a stack data structure for its implementation.</p>
  
  <p><strong>Key Characteristics of DFT:</strong></p>
  <ul>
    <li>Explores deeply into the graph before backtracking</li>
    <li>Uses a stack data structure (either explicitly or via recursion)</li>
    <li>Visits all nodes connected from a starting node</li>
    <li>Can detect cycles when implemented with proper tracking</li>
    <li>Often simpler to implement than breadth-first traversal for recursive problems</li>
  </ul>
</div>

<div class="content-section">
  <h4>Graph Representation</h4>
  <p>Before implementing DFT, we need a way to represent our graph. Common representations include:</p>
  
  <div class="code-block">
// Adjacency List representation
class Graph {
  constructor() {
    this.adjacencyList = {};
  }
  
  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) {
      this.adjacencyList[vertex] = [];
    }
  }
  
  addEdge(vertex1, vertex2) {
    this.adjacencyList[vertex1].push(vertex2);
    // For undirected graph, add the reverse edge too
    // this.adjacencyList[vertex2].push(vertex1);
  }
}
  </div>
</div>

<div class="content-section">
  <h4>Recursive DFT Implementation</h4>
  <p>The recursive approach to DFT leverages the call stack to keep track of vertices to visit:</p>
  
  <div class="code-block">
// Recursive DFT implementation
class Graph {
  // ... previous methods from above ...
  
  depthFirstTraversalRecursive(startVertex) {
    const result = [];
    const visited = {};
    const adjacencyList = this.adjacencyList;
    
    // Helper function to conduct DFT recursively
    function dfs(vertex) {
      if (!vertex) return null;
      
      // Mark vertex as visited
      visited[vertex] = true;
      // Add vertex to result
      result.push(vertex);
      
      // Visit each neighbor
      adjacencyList[vertex].forEach(neighbor => {
        if (!visited[neighbor]) {
          return dfs(neighbor);
        }
      });
    }
    
    // Start DFT from startVertex
    dfs(startVertex);
    
    return result;
  }
}

// Example usage
const g = new Graph();
g.addVertex("A");
g.addVertex("B");
g.addVertex("C");
g.addVertex("D");
g.addVertex("E");
g.addVertex("F");

g.addEdge("A", "B");
g.addEdge("A", "C");
g.addEdge("B", "D");
g.addEdge("C", "E");
g.addEdge("D", "E");
g.addEdge("D", "F");
g.addEdge("E", "F");

console.log(g.depthFirstTraversalRecursive("A")); // ["A", "B", "D", "E", "F", "C"]
  </div>
</div>

<div class="content-section">
  <h4>Iterative DFT Implementation</h4>
  <p>The iterative approach uses an explicit stack to keep track of vertices to visit:</p>
  
  <div class="code-block">
// Iterative DFT implementation
class Graph {
  // ... previous methods ...
  
  depthFirstTraversalIterative(startVertex) {
    const stack = [startVertex];
    const result = [];
    const visited = {};
    visited[startVertex] = true;
    
    while (stack.length) {
      const currentVertex = stack.pop();
      result.push(currentVertex);
      
      this.adjacencyList[currentVertex].forEach(neighbor => {
        if (!visited[neighbor]) {
          visited[neighbor] = true;
          stack.push(neighbor);
        }
      });
    }
    
    return result;
  }
}

// Example usage
console.log(g.depthFirstTraversalIterative("A")); // May produce different order than recursive version
  </div>
  
  <p><strong>Time Complexity:</strong> O(V + E) where V is the number of vertices and E is the number of edges</p>
  <p><strong>Space Complexity:</strong> O(V) for the visited set and stack/recursion call stack</p>
</div>

<div class="content-section">
  <h4>Applications of DFT</h4>
  <ul>
    <li><strong>Cycle Detection:</strong> Detect if a graph contains a cycle</li>
    <li><strong>Path Finding:</strong> Find a path between two nodes</li>
    <li><strong>Topological Sorting:</strong> Linear ordering of vertices in a directed acyclic graph</li>
    <li><strong>Connected Components:</strong> Find connected components in an undirected graph</li>
    <li><strong>Solving Puzzles:</strong> Maze solving, Sudoku solving, etc.</li>
  </ul>
  
  <h4>DFT vs. BFT Comparison</h4>
  <table class="data-table">
    <tr>
      <th class="table-header">Aspect</th>
      <th class="table-header">Depth-First Traversal</th>
      <th class="table-header">Breadth-First Traversal</th>
    </tr>
    <tr>
      <td class="table-cell">Data Structure</td>
      <td class="table-cell">Stack (explicit or call stack)</td>
      <td class="table-cell">Queue</td>
    </tr>
    <tr>
      <td class="table-cell">Traversal Pattern</td>
      <td class="table-cell">Deep exploration before backtracking</td>
      <td class="table-cell">Level by level exploration</td>
    </tr>
    <tr>
      <td class="table-cell">Best For</td>
      <td class="table-cell">Path finding, maze solving, topological sort</td>
      <td class="table-cell">Shortest path, social networks, level-order tasks</td>
    </tr>
    <tr>
      <td class="table-cell">Memory Usage</td>
      <td class="table-cell">Lower for deep graphs</td>
      <td class="table-cell">Lower for wide graphs</td>
    </tr>
    <tr>
      <td class="table-cell">Implementation</td>
      <td class="table-cell">Simpler recursive solution</td>
      <td class="table-cell">Usually implemented iteratively</td>
    </tr>
  </table>
</div>

<h3>Practice with LeetCode Problems</h3>

<p>Note: Previously, this course referenced the CodeSignal Arcade for practice, which is no longer available. The LeetCode problems below follow the same principles and are an excellent alternative for practicing graph traversal.</p>

<ul>
  <li><a href="https://leetcode.com/problems/number-of-islands/" class="leetcode-link" target="_blank" rel="noopener">Number of Islands</a> - Classic DFT/DFS problem</li>
  <li><a href="https://leetcode.com/problems/clone-graph/" class="leetcode-link" target="_blank" rel="noopener">Clone Graph</a> - Deep copy a graph using DFT</li>
  <li><a href="https://leetcode.com/problems/course-schedule/" class="leetcode-link" target="_blank" rel="noopener">Course Schedule</a> - Cycle detection with DFT</li>
  <li><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" class="leetcode-link" target="_blank" rel="noopener">Pacific Atlantic Water Flow</a> - DFT with multiple starting points</li>
  <li><a href="https://leetcode.com/problems/flood-fill/" class="leetcode-link" target="_blank" rel="noopener">Flood Fill</a> - Simple application of DFT</li>
</ul>

</body>
</html>