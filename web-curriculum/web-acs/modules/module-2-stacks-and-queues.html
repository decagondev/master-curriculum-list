<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Module 2: Stacks and Queues</title>
<meta name="identifier" content="ga7c18c981affe75aba71f746991bdd39"/>
<meta name="editing_roles" content="teachers"/>
<meta name="workflow_state" content="active"/>
<style>
  .code-block {
    background-color: #f5f5f5;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-family: monospace;
    white-space: pre;
    overflow-x: auto;
  }
  
  .leetcode-link {
    color: #FF8C00;
    text-decoration: none;
  }
  
  .leetcode-link:hover {
    text-decoration: underline;
  }
  
  .objectives-section {
    margin-bottom: 20px;
    padding: 10px;
    border-left: 3px solid #93005a;
    background-color: #f9f9f9;
  }
  
  .content-section {
    margin-bottom: 20px;
  }

  /* Video container styles */
  .video-container {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
    margin: 15px 0;
  }
  
  .video-wrapper {
    height: 100%;
    left: 0;
    position: absolute;
    top: 0;
    width: 100%;
  }

  /* Table styles */
  .data-table {
    border-collapse: collapse;
    width: 100%;
  }

  .table-header {
    padding: 8px;
    background-color: #f0f0f0;
  }

  .table-cell {
    padding: 8px;
    border: 1px solid #ddd;
  }
</style>
</head>
<body>
<div class="objectives-section">
  <h2>Module Objectives</h2>
  <p>Upon completion of this module you will be able to:</p>
  <ul>
    <li>Understand what a stack is and its behavior (LIFO - Last In, First Out)</li>
    <li>Understand what a queue is and its behavior (FIFO - First In, First Out)</li>
    <li>Write code to implement a stack and its basic operations: push, pop, peek, isEmpty</li>
    <li>Write code to implement a queue and its basic operations: enqueue, dequeue, peek, isEmpty</li>
    <li>Apply stacks and queues to solve common programming problems</li>
    <li>Analyze the time and space complexity of stack and queue operations</li>
  </ul>
</div>

<h3><strong>Stack Basics</strong></h3>
<p>
<div class="video-container">
  <div class="video-wrapper">
    <iframe class="wistia_embed" title="s17M2 JavaScript - Stack Basics Video" src="https://fast.wistia.net/embed/iframe/81ip5021u2" width="100%" height="100%" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe>
  </div>
</div>
</p>

<div class="content-section">
  <h4>Understanding Stacks</h4>
  <p>A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle. Think of it like a stack of plates - you can only take the top plate, and you always add new plates to the top.</p>
  
  <p><strong>Key Stack Operations:</strong></p>
  <ul>
    <li><strong>Push:</strong> Add an element to the top of the stack</li>
    <li><strong>Pop:</strong> Remove and return the top element</li>
    <li><strong>Peek/Top:</strong> View the top element without removing it</li>
    <li><strong>isEmpty:</strong> Check if the stack is empty</li>
  </ul>
  
  <div class="code-block">
// Stack implementation using array
class Stack {
  constructor() {
    this.items = [];
  }
  
  // Add element to top of stack
  push(element) {
    this.items.push(element);
  }
  
  // Remove and return the top element
  pop() {
    if (this.isEmpty()) {
      return "Underflow - Stack is empty";
    }
    return this.items.pop();
  }
  
  // Return the top element without removing it
  peek() {
    if (this.isEmpty()) {
      return "Stack is empty";
    }
    return this.items[this.items.length - 1];
  }
  
  // Check if stack is empty
  isEmpty() {
    return this.items.length === 0;
  }
  
  // Return the size of the stack
  size() {
    return this.items.length;
  }
  
  // Clear the stack
  clear() {
    this.items = [];
  }
}

// Usage example
const stack = new Stack();
stack.push(10);
stack.push(20);
stack.push(30);
console.log(stack.peek());  // 30
console.log(stack.pop());   // 30
console.log(stack.size());  // 2
  </div>
  
  <p><strong>Common Stack Applications:</strong></p>
  <ul>
    <li>Function call management (call stack)</li>
    <li>Expression evaluation and syntax parsing</li>
    <li>Undo mechanisms in applications</li>
    <li>Backtracking algorithms</li>
    <li>Browser history</li>
  </ul>
</div>

<h3><strong>Queue Basics</strong></h3>
<p>
<div class="video-container">
  <div class="video-wrapper">
    <iframe class="wistia_embed" title="S17M2 Understand What a Queue is and its Behavior Video" src="https://fast.wistia.net/embed/iframe/9k6pi75srk" width="100%" height="100%" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe>
  </div>
</div>
</p>

<div class="content-section">
  <h4>Understanding Queues</h4>
  <p>A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. Think of it like a line of people - the first person to join the line is the first person served.</p>
  
  <p><strong>Key Queue Operations:</strong></p>
  <ul>
    <li><strong>Enqueue:</strong> Add an element to the end of the queue</li>
    <li><strong>Dequeue:</strong> Remove and return the front element</li>
    <li><strong>Front/Peek:</strong> View the front element without removing it</li>
    <li><strong>isEmpty:</strong> Check if the queue is empty</li>
  </ul>
  
  <div class="code-block">
// Queue implementation using array
class Queue {
  constructor() {
    this.items = [];
  }
  
  // Add element to the end of the queue
  enqueue(element) {
    this.items.push(element);
  }
  
  // Remove and return the front element
  dequeue() {
    if (this.isEmpty()) {
      return "Underflow - Queue is empty";
    }
    return this.items.shift();
  }
  
  // Return the front element without removing it
  front() {
    if (this.isEmpty()) {
      return "Queue is empty";
    }
    return this.items[0];
  }
  
  // Check if queue is empty
  isEmpty() {
    return this.items.length === 0;
  }
  
  // Return the size of the queue
  size() {
    return this.items.length;
  }
  
  // Clear the queue
  clear() {
    this.items = [];
  }
}

// Usage example
const queue = new Queue();
queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
console.log(queue.front());    // 10
console.log(queue.dequeue());  // 10
console.log(queue.size());     // 2
  </div>
  
  <p><strong>More Efficient Queue Implementation</strong></p>
  <p>The array implementation above has O(n) time complexity for the dequeue operation due to array shift. A more efficient implementation uses an object with separate tracking for front and rear:</p>
  
  <div class="code-block">
// Queue implementation with O(1) operations
class OptimizedQueue {
  constructor() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }
  
  enqueue(element) {
    this.items[this.backIndex] = element;
    this.backIndex++;
  }
  
  dequeue() {
    if (this.isEmpty()) {
      return "Underflow - Queue is empty";
    }
    
    const item = this.items[this.frontIndex];
    delete this.items[this.frontIndex];
    this.frontIndex++;
    return item;
  }
  
  front() {
    if (this.isEmpty()) {
      return "Queue is empty";
    }
    return this.items[this.frontIndex];
  }
  
  isEmpty() {
    return this.backIndex - this.frontIndex === 0;
  }
  
  size() {
    return this.backIndex - this.frontIndex;
  }
}
  </div>
  
  <p><strong>Common Queue Applications:</strong></p>
  <ul>
    <li>Task scheduling</li>
    <li>Printer spooling</li>
    <li>Request handling in web servers</li>
    <li>Breadth-first search algorithms</li>
    <li>Message queues in distributed systems</li>
  </ul>
</div>

<h3>Variations and Special Types</h3>

<div class="content-section">
  <h4>Circular Queue</h4>
  <p>A circular queue is a special implementation where the front and rear are connected in a circular fashion, optimizing space usage.</p>
  
  <h4>Priority Queue</h4>
  <p>A priority queue assigns a priority to each element, and elements with higher priority are served before elements with lower priority, regardless of their position in the queue.</p>
  
  <h4>Deque (Double-Ended Queue)</h4>
  <p>A deque allows insertion and deletion at both ends, combining features of both stacks and queues.</p>
</div>

<h3>Practice with LeetCode Problems</h3>

<p>Note: Previously, this course referenced the CodeSignal Arcade for practice, which is no longer available. The LeetCode problems below follow the same principles and are an excellent alternative for practicing stack and queue implementations.</p>

<h4>Stack Problems:</h4>
<ul>
  <li><a href="https://leetcode.com/problems/valid-parentheses/" class="leetcode-link" target="_blank" rel="noopener">Valid Parentheses</a> - Use a stack to check valid opening/closing of brackets</li>
  <li><a href="https://leetcode.com/problems/min-stack/" class="leetcode-link" target="_blank" rel="noopener">Min Stack</a> - Implement a stack with constant time access to minimum element</li>
  <li><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" class="leetcode-link" target="_blank" rel="noopener">Evaluate Reverse Polish Notation</a> - Use a stack to evaluate postfix expressions</li>
</ul>

<h4>Queue Problems:</h4>
<ul>
  <li><a href="https://leetcode.com/problems/implement-queue-using-stacks/" class="leetcode-link" target="_blank" rel="noopener">Implement Queue using Stacks</a> - Build a queue using two stacks</li>
  <li><a href="https://leetcode.com/problems/design-circular-queue/" class="leetcode-link" target="_blank" rel="noopener">Design Circular Queue</a> - Implement a circular queue</li>
  <li><a href="https://leetcode.com/problems/number-of-recent-calls/" class="leetcode-link" target="_blank" rel="noopener">Number of Recent Calls</a> - Practical application of queues</li>
</ul>

<hr>

<div class="content-section">
  <h4>Recursion vs. Iteration</h4>
  <p>It's important to understand when to use recursion versus iterative approaches:</p>
  
  <table class="data-table">
    <tr>
      <th class="table-header">Aspect</th>
      <th class="table-header">Recursion</th>
      <th class="table-header">Iteration</th>
    </tr>
    <tr>
      <td class="table-cell">Memory Usage</td>
      <td class="table-cell">Uses call stack (higher memory overhead)</td>
      <td class="table-cell">Typically uses less memory</td>
    </tr>
    <tr>
      <td class="table-cell">Code Clarity</td>
      <td class="table-cell">Often more elegant and readable for certain problems</td>
      <td class="table-cell">May be more straightforward for simple problems</td>
    </tr>
    <tr>
      <td class="table-cell">Performance</td>
      <td class="table-cell">Can be slower due to function call overhead</td>
      <td class="table-cell">Usually faster</td>
    </tr>
    <tr>
      <td class="table-cell">Stack Overflow Risk</td>
      <td class="table-cell">Possible with deep recursion</td>
      <td class="table-cell">Not an issue</td>
    </tr>
    <tr>
      <td class="table-cell">Best For</td>
      <td class="table-cell">Tree traversals, divide-and-conquer algorithms</td>
      <td class="table-cell">Simple loops, performance-critical code</td>
    </tr>
  </table>
</div>
</body>
</html>